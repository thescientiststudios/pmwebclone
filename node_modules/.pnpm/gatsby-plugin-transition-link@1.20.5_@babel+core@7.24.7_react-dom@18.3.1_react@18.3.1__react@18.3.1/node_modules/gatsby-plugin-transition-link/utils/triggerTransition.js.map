{"version":3,"sources":["../../src/utils/triggerTransition.js"],"names":["triggerTransition","to","event","exit","entry","inTransition","pages","trigger","updateContext","linkState","replace","preventScrollJump","persist","preventDefault","hash","includes","toSplit","split","window","__tl_inTransition","__tl_desiredPathname","exitDelay","exitLength","appearAfter","exitState","length","delay","state","exitTrigger","entryLength","entryDelay","entryState","entryTrigger","entryProps","exitProps","node","e","finalResetSeconds","Math","max","__tl_back_button_pressed"],"mappings":"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","sourcesContent":["import { navigate, withPrefix } from 'gatsby'\nimport { setTimeout } from 'requestanimationframe-timer'\nimport { getMs } from './secondsMs'\nimport getPagesPromises from './getPagesPromises'\n\nconst triggerTransition = ({\n\tto,\n\tevent = null,\n\texit = {},\n\tentry = {},\n\tinTransition,\n\tpages,\n\ttrigger,\n\tupdateContext,\n\tlinkState,\n\treplace,\n\tpreventScrollJump,\n}) => {\n\tif (event) {\n\t\tevent.persist()\n\t\tevent.preventDefault()\n\t}\n\n\tif (inTransition) return false\n\n\tlet hash\n\n\t// handle anchor links to ID's\n\tif (to.includes('#')) {\n\t\tconst toSplit = to.split('#')\n\t\tto = toSplit[0]\n\t\thash = toSplit[1]\n\t}\n\n\t// these globals prevent the back button from being pressed during a transition as that can have unexpected results\n\twindow.__tl_inTransition = true\n\twindow.__tl_desiredPathname = withPrefix(to)\n\n\tupdateContext({\n\t\tinTransition: true,\n\t\texitDelay: 0,\n\t\texitLength: 0,\n\t\tappearAfter: 0,\n\t\texitState: {},\n\t})\n\n\tif (trigger && typeof trigger === 'function') {\n\t\ttrigger(pages)\n\t}\n\n\tconst {\n\t\tlength: exitLength = 0,\n\t\tdelay: exitDelay = 0,\n\t\tstate: exitState = {},\n\t\ttrigger: exitTrigger = () => {},\n\t} = exit\n\tconst {\n\t\tlength: entryLength = 1, // this allows scrollposition to be reset when there is no transition.\n\t\tdelay: entryDelay = 0,\n\t\tstate: entryState = {},\n\t\ttrigger: entryTrigger = () => {},\n\t\tappearAfter = 0,\n\t} = entry\n\n\tupdateContext({\n\t\tentryLength: entryLength,\n\t\tentryDelay: entryDelay,\n\t\texitLength: exitLength,\n\t\texitDelay: exitDelay,\n\t\tentryProps: entry,\n\t\texitProps: exit,\n\t\tappearAfter,\n\t\tpreventScrollJump,\n\t\texitTrigger: (exit, node, e) => exitTrigger(exit, node, e),\n\t\tentryTrigger: (entry, node, e) => entryTrigger(entry, node, e),\n\t\te: event,\n\t})\n\n\t// after exitDelay\n\tsetTimeout(() => {\n\t\tnavigate(to, {\n\t\t\tstate: {\n\t\t\t\t...linkState,\n\t\t\t},\n\t\t\treplace,\n\t\t})\n\n\t\tupdateContext({\n\t\t\texitState: exitState,\n\t\t\thash,\n\t\t})\n\t}, getMs(exitDelay))\n\n\tsetTimeout(() => {\n\t\t// wait for entryDelay before we add entry state\n\t\tupdateContext({ entryState: entryState })\n\t}, getMs(exitDelay + entryDelay))\n\n\t// reset entry animation times so they dont apply when using browser back/forward.\n\t//  this will be replaced with a better solution in the future\n\tsetTimeout(\n\t\t() =>\n\t\t\tupdateContext({\n\t\t\t\tentryDelay: 0,\n\t\t\t\tappearAfter: 0,\n\t\t\t\tentryLength: 0,\n\t\t\t}),\n\t\tgetMs(exitDelay + entryDelay + entryLength)\n\t)\n\n\tconst finalResetSeconds =\n\t\texitDelay + Math.max(exitLength, entryDelay + entryLength)\n\n\t// reset exit animation times so they dont apply when using browser back/forward.\n\t//  this will be replaced with a better solution in the future\n\tsetTimeout(() => {\n\t\t// these globals prevent the back button from being pressed during a transition as that can have unexpected results\n\t\twindow.__tl_inTransition = false\n\t\twindow.__tl_desiredPathname = false\n\t\twindow.__tl_back_button_pressed = false\n\n\t\tupdateContext({\n\t\t\texitDelay: 0,\n\t\t\texitLength: 0,\n\t\t\t// Once all animation is finished, it's safe to start a new animation since we're no longer inTransition.\n\t\t\tinTransition: false,\n\t\t\t// create new page promises for the trigger prop\n\t\t\t...getPagesPromises(),\n\t\t})\n\t}, getMs(finalResetSeconds) + 1)\n}\n\nexport { triggerTransition }\n"],"file":"triggerTransition.js"}